component displayname="ToolCreator" {
    
    /**
     * Tool for creating new tools dynamically!
     * This is the meta-tool that enables self-improvement
     */
    
    public struct function executeTool(required string toolName, required struct args) {
        try {
            switch(arguments.toolName) {
                case "createTool":
                    return createNewTool(arguments.args);
                    
                case "addToolRegistration":
                    return addToolRegistration(arguments.args);
                    
                default:
                    throw(type="ToolNotFound", message="Unknown tool creator function: #arguments.toolName#");
            }
            
        } catch (any e) {
            return {
                "content": [{
                    "type": "text",
                    "text": "Error in tool creator: #e.message#"
                }],
                "isError": true
            };
        }
    }
    private void function validateRequiredParams(required struct args, required array required) {
        for (var param in arguments.required) {
            if (!structKeyExists(arguments.args, param) || len(trim(arguments.args[param])) == 0) {
                throw(type="InvalidParams", message="Missing required parameter: #param#");
            }
        }
    }

     private struct function createNewTool(required struct args) {
     validateRequiredParams(arguments.args, ["toolName", "description", "code"]);
     
    // Validate toolName contains only safe characters
    if (!reMatch("^[a-zA-Z][a-zA-Z0-9_]*$", arguments.args.toolName)) {
        throw(type="InvalidParams", message="Tool name must contain only alphanumeric characters and underscores");
    }
    
    // Basic code validation - reject obvious malicious patterns
    var codeContent = arguments.args.code;
    var dangerousPatterns = [
        "<cfexecute", "<cffile", "<cfdirectory", "<cfregistry", "<cfldap",
        "createObject(""java""", "createObject('java')", 
        "fileWrite", "fileRead", "fileDelete", "directoryCreate", "directoryDelete",
        "invoke(", "evaluate(", "cfinclude", "cfmodule",
        "application.stop", "server.stop", "createObject(""com""",
        "getPageContext()", "getMetaData()"
    ];
    for (var pattern in dangerousPatterns) {
        if (findNoCase(pattern, codeContent)) {
            throw(type="SecurityError", message="Code contains potentially dangerous operations");
        }
    }
     
     var toolName = arguments.args.toolName;
     var fileName = toolName & "Tool.cfc";
    
    // Ensure file path is within expected directory
    var toolsDir = expandPath("/mcpcfc/tools/");
    var filePath = toolsDir & fileName;
    if (!filePath.startsWith(toolsDir)) {
        throw(type="SecurityError", message="Invalid file path");
    }
        
        // Generate the tool component code
        var toolCode = 'component displayname="#encodeForHTMLAttribute(toolName)#Tool" {
     
     /**
     * #encodeForHTML(arguments.args.description)#
      * Auto-generated by ToolCreator
      */
     
     public struct function executeTool(required string toolName, required struct args) {
         try {
             switch(arguments.toolName) {
                case "#encodeForHTMLAttribute(lCase(toolName))#":
                    return execute#encodeForHTMLAttribute(toolName)#(arguments.args);
                    
                default:
                    throw(type="ToolNotFound", message="Unknown tool: ##arguments.toolName##");
            }
            
        } catch (any e) {
            return {
                "content": [{
                    "type": "text",
                    "text": "Error executing tool: ##e.message##"
                }],
                "isError": true
            };
        }
    }
    
    private struct function execute#toolName#(required struct args) {
        // TODO: Implement proper sandboxing mechanism
        // For now, return error to prevent code injection
        throw(type="SecurityError", message="Dynamic code execution disabled for security");
    }
    
    private void function validateRequiredParams(required struct args, required array required) {
        for (var param in arguments.required) {
            if (!structKeyExists(arguments.args, param) || len(trim(arguments.args[param])) == 0) {
                throw(type="InvalidParams", message="Missing required parameter: ##param##");
            }
        }
    }
}';
        
        // Write the new tool file
        fileWrite(filePath, toolCode);
        
        return {
            "content": [{
                "type": "text",
                "text": "Successfully created new tool: #toolName#Tool.cfc at #filePath#. Remember to add the tool registration to Application.cfc and restart Claude Desktop!"
            }]
        };
    }
    
    private struct function addToolRegistration(required struct args) {
        validateRequiredParams(arguments.args, ["toolName", "description", "inputSchema"]);
        
var registrationCode = '
 // Auto-generated tool registration
application.toolRegistry.registerTool("#encodeForJavaScript(lCase(arguments.args.toolName))#", {
    "description": "#encodeForJavaScript(arguments.args.description)#",
    "inputSchema": #serializeJson(arguments.args.inputSchema)#
 });';
        
        return {
            "content": [{
                "type": "text",
                "text": "Add this registration code to your Application.cfc registerTools() function:#chr(10)##chr(10)##registrationCode#"
            }]
        };
    }
    

}