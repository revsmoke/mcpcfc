component displayname="ToolCreator" extends="mcpcfc.tools.BaseTool" {
    
    /**
     * Tool for creating new tools dynamically!
     * This is the meta-tool that enables self-improvement
     */
    
    public struct function executeTool(required string toolName, required struct args) {
        try {
            switch(arguments.toolName) {
                case "createTool":
                    return createNewTool(arguments.args);
                    
                case "addToolRegistration":
                    return addToolRegistration(arguments.args);
                    
                default:
                    throw(type="ToolNotFound", message="Unknown tool creator function: #arguments.toolName#");
            }
            
        } catch (any e) {
            return {
                "content": [{
                    "type": "text",
                    "text": "Error in tool creator: #e.message#"
                }],
                "isError": true
            };
        }
    }
    // validateRequiredParams is now inherited from BaseTool

private struct function createNewTool(required struct args) {
    // Add role-based access control
    if (!structKeyExists(session, "userRole") || session.userRole != "admin") {
        throw(type="SecurityError", message="Tool creation requires admin privileges");
    }
    
     validateRequiredParams(arguments.args, ["toolName", "description", "code"]);
     
    // Enhanced toolName validation
    if (len(arguments.args.toolName) < 3 || len(arguments.args.toolName) > 50 ||
        refindNoCase("^[a-zA-Z][a-zA-Z0-9_]*$", arguments.args.toolName) EQ 0) {
         throw(type="InvalidParams", message="Tool name must contain only alphanumeric characters and underscores");
     }
     
    // Check for reserved/system tool names
    var reservedNames = ["system", "admin", "security", "file", "database", "server"];
    for (var reserved in reservedNames) {
        if (findNoCase(reserved, arguments.args.toolName)) {
            throw(type="InvalidParams", message="Tool name contains reserved keyword: #reserved#");
        }
    }
    
     // Basic code validation - reject obvious malicious patterns
     var codeContent = arguments.args.code;
    var dangerousPatterns = [
         "<cfexecute", "<cffile", "<cfdirectory", "<cfregistry", "<cfldap",
         "createObject(""java""", "createObject('java')", 
         "fileWrite", "fileRead", "fileDelete", "directoryCreate", "directoryDelete",
         "invoke(", "evaluate(", "cfinclude", "cfmodule",
         "application.stop", "server.stop", "createObject(""com""",
        "getPageContext()", "getMetaData()", "cfscript", "<cf", 
        "writeLog", "writeDump", "cfquery", "queryExecute"
     ];
    
     for (var pattern in dangerousPatterns) {
         if (findNoCase(pattern, codeContent)) {
            throw(type="SecurityError", message="Code contains forbidden operation: #pattern#");
         }
     }
    
    // Additional validation: check code length and complexity
    if (len(codeContent) > 10000) {
        throw(type="SecurityError", message="Code too long (max 10KB)");
    }
     
     var toolName = arguments.args.toolName;
     var fileName = toolName & "Tool.cfc";
    
    // Ensure file path is within expected directory
    var toolsDir = expandPath("/mcpcfc/tools/");
    var filePath = toolsDir & fileName;
    if (!filePath.startsWith(toolsDir)) {
        throw(type="SecurityError", message="Invalid file path");
    }
        
        // Generate the tool component code that extends BaseTool
        var toolCode = 'component displayname="' & encodeForHTMLAttribute(toolName) & 'Tool" extends="mcpcfc.tools.BaseTool" {
     
     /**
     * ' & encodeForHTML(arguments.args.description) & '
      * Auto-generated by ToolCreator
      */
     
     public struct function executeTool(required string toolName, required struct args) {
         try {
             switch(arguments.toolName) {
                case "' & encodeForHTMLAttribute(lCase(toolName)) & '":
                    return execute' & encodeForHTMLAttribute(toolName) & '(arguments.args);
                    
                default:
                    throw(type="ToolNotFound", message="Unknown tool: ##arguments.toolName##");
            }
            
        } catch (any e) {
            return {
                "content": [{
                    "type": "text",
                    "text": "Error executing tool: ##e.message##"
                }],
                "isError": true
            };
        }
    }
    
    private struct function execute' & toolName & '(required struct args) {
        // TODO: Implement proper sandboxing mechanism
        // For now, return error to prevent code injection
        throw(type="SecurityError", message="Dynamic code execution disabled for security");
    }
}';
        
// Write the new tool file with exclusive lock to prevent race conditions
         lock name="toolCreator_#fileName#" type="exclusive" timeout="10" {
            // Audit log the tool creation
            writeLog(file="security", type="information", 
                     text="Tool created: #toolName# by #getAuthUser()# at #now()#");
             fileWrite(filePath, toolCode);
         }
        
        return {
            "content": [{
                "type": "text",
                "text": "Successfully created new tool: #toolName#Tool.cfc at #filePath#. Remember to add the tool registration to Application.cfc and restart Claude Desktop!"
            }]
        };
    }
    
private struct function addToolRegistration(required struct args) {
    // Access control check
    if (!structKeyExists(session, "userRole") || session.userRole != "admin") {
        throw(type="SecurityError", message="Tool registration requires admin privileges");
    }
    
     validateRequiredParams(arguments.args, ["toolName", "description", "inputSchema"]);
     
    // Validate tool name format
    if (refindNoCase("^[a-zA-Z][a-zA-Z0-9_]*$", arguments.args.toolName) EQ 0) {
        throw(type="InvalidParams", message="Invalid tool name format");
    }
    
    // Validate description length
    if (len(arguments.args.description) > 500) {
        throw(type="InvalidParams", message="Description too long (max 500 characters)");
    }
    
    // Validate inputSchema is proper JSON
    try {
        deserializeJson(serializeJson(arguments.args.inputSchema));
    } catch (any e) {
        throw(type="InvalidParams", message="Invalid input schema format");
    }
    
 var registrationCode = '
  // Auto-generated tool registration
// Created: ' & dateTimeFormat(now(), "yyyy-mm-dd HH:nn:ss") & '
// Created by: ' & encodeForJavaScript(getAuthUser()) & '
application.toolRegistry.registerTool("' & encodeForJavaScript(lCase(arguments.args.toolName)) & '", {
    "description": "' & encodeForJavaScript(left(arguments.args.description, 500)) & '",
    "inputSchema": ' & serializeJson(arguments.args.inputSchema) & ',
    "autoGenerated": true,
    "requiresApproval": true
  });';
        
        // Log the registration generation
        writeLog(file="security", type="information", 
                 text="Registration code generated for tool: #arguments.args.toolName# by #getAuthUser()#");
        
        return {
            "content": [{
                "type": "text",
                "text": "Add this registration code to your Application.cfc registerTools() function:#chr(10)##chr(10)##registrationCode#"
            }]
        };
    }
    

}        writeLog(file="security", type="information", 
                 text="Registration code generated for tool: #arguments.args.toolName# by #getAuthUser()#");
        
        return {
            "content": [{
                "type": "text",
                "text": "Add this registration code to your Application.cfc registerTools() function:#chr(10)##chr(10)##registrationCode#"
            }]
        };
    }
    

}